# Задание №18

## Задача №1

Написать клиент-серверное приложение "Гадалка"

Сервер: отвечает за подключение новых клиентов (максимум MAX_COUNT_OF_THREADS)

Каждый новый клиент обрабатывается в отдельном потоке

Поведение клиента и сервера подчиняется протоколу:

1. Сервер подключается - ждёт подключения нового клиента
2. Клиент подключается и отправляет число, введённое пользователем
3. Сервер отвечает либо ДА либо НЕТ в качестве переменной типа boolean
4. Операция повторяется, пока клиент не угадает число


## Задача №2

Разработать клиент-серверное приложение SchoolChat

• Вход в систему по логину – дополнительных проверок не надо делать
• Историю чатов хранить не нужно
• Сервер понимает 2 команды:
    • Отправить сообщение пользователю
    • Получить все сообщения адресованные текущему пользователю
• Клиент при получении сообщения просто выводит информацию:
    • «user >> message_text»
• При входе нового пользователя все участники чата получают нотификацию (сообщение от пользователя system)


### Реализация

Взаимодействие между клиентом и сервером осуществляется при при помощи сокетов.
Сервер ожидает подключения новых клиентов по определённому адресу и порту по TCP протоколу, 
а также запускает в отдельном процессе-демоне подсерве, ожидающий подключений 
по UPD протоколу (для рассылки уведомлений клиентам).
При подключении нового клиента, сервер запускает отдельный процесс серверного приложения для взаимодействия с ним. 
Количество клиентов ограничено количеством доступных тред в пуле, так как большое количество
постоянно поддерживаемых TCP соединений и самих подпроцессов достаточно накладно.

Каждый новый сервер-процесс получает на вход сокет для взаимодействия и создаёт при помощи него
экземпляр класса **Person** для хранения информации о клиенте:

1. Логин клиента (только подключившийся клиент получает логин anonymous)
2. Очередь предназначенных клиенту сообщений, но ещё не запрошеных (очередь ограничена 10 записями)
3. Скомпанованную информацию о сокете клиента и входном и выходном потоке этого сокета для взаимодействия
4. Методы для добавления / взятия сообщений из истории сообщений, 
установления логина пользователя после авторизации и получения потоков воода-вывода для получения от него / отправки ему сообщений.

Как только новый пользователь подключился, сервер инициирует процесс авторизации клиента по логину.
Для этого сервер отправляет клиенту запрос на введение логина. Если клиент не вышел из чата набрав команду exit
и ввёл логин, то сервер проверяет наличие указанного клиентом логина в карте клиентов:

1. Если пользователя в карте нет - сервер добавляет нового пользователя в карту и считает его авторизованным
2. Иначе, проверяет, если пользователь в карте ранее разорвал соединение, то авторизует нового клиента как старого пользователя
и клонирует его старую переписку. А если старый пользователь не разорвал соединение, то отправляет клиенту сообщение об ошибке и 
повторяет запрос логина.

Когда клиент запрашивает какую-либо команду, будь до запрос на список сообщений,
или запрос на разрыв соединения, или даже написание сообщения пользователю чата, на
самом деле происходит следующая последовательность действий:

1. Устанавливается корректность ввода клиентом, то есть что именно ввёл клиент (запрос / сообщение / ошибочный ввод)
2. Если ввод корректный и это команда - она отправляется сразу на сервер, а если сообщение - на сервер отправляется команда
для подготовки сервера к принятию сообщения
3. Сервер ожидает команду от клиента и после получения возвращает соответствующий ответ:
 - Если это запрос на список сообщений клиента - возвращает сериализованный список объектов типпа Message
 - Если это запрос на разрыв соединения - завершает бесконечный цикл ожидания команд от клиента, 
 закрывает сокет и потоки ввода-вывода и завершает работу трэды
 - Если это запрос-уведомлении об отправке нового сообщения - готовится к принятию сериализованного объекта типа Message 
 и отправляет команду о готовности
4. Приложение клиента принимает ответ от сервера и выполняет дальнейшие действия, связанные с командой 
(вывод списка сообщений / отправка нового сообщения / завершение работы приложения)
5. При отправке нового сообщения клиентом, на последней стадии клиентское приложение ожидает ответ от сервера и выводит его пользователю.

Всё взаимодействие между клиентом и сервером происходит при помощи единого протокола,
реализованного в классе **Protocol** и наследуемого клиентским и серверным приложением.
Этот класс содержит два общих метода **tryAuth** и **communication** для описания последовательности
взаимодействий приложений, а также некоторый набор методов реализующих либо конкретную команду, либо промежуточное действие.
Каждое приложение должно реализовать эти методы у себя в соответствии с детальным протоколом по каждой команде
(все, кроме tryAuth и communication - эти методы являются неизменяемыми).

При помощи UDP протокола реализовано мгновенное оповещение всех клиентов о входе в чат и выходе из чата клиентов.

Сервер, работающий по UDP протоколу блокируется на SynchronousQueue очереди с одним сообщением.
При добавлении одинм из потоков сообщения в очередь - сервер отправляет широковещательное сообщение по
определённому порту всем подключённым по UDP клиентам.

Клиентское приложение дополнительно запускает поток-демон на ожидание сообщений по UDP протоколу, где 
ожидает поступления новых сообщений. Когда сообщение поступает - выводит его в поток вывода клиентского приложения.




